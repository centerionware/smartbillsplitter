import React, { useState, useEffect, useCallback } from 'react';
import type { RequestConfirmationFn } from '../App.tsx';
import { exportData, importData } from '../services/db.ts';
import * as cryptoService from '../services/cryptoService.ts';
import { useAppControl } from '../contexts/AppControlContext.tsx';
import { useQrScanner } from '../hooks/useQrScanner.ts';

interface SyncProps {
  onBack: () => void;
  requestConfirmation: RequestConfirmationFn;
}

type Mode = 'idle' | 'sharing' | 'receiving' | 'error';
type ShareStatus = 'generating' | 'waiting';
type ReceiveStatus = 'scanning' | 'connecting' | 'decrypting' | 'confirming' | 'complete';

// A simple component to render a countdown timer.
const CountdownTimer: React.FC<{ expiry: number; onExpire: () => void }> = ({ expiry, onExpire }) => {
  const [timeLeft, setTimeLeft] = useState(expiry - Date.now());

  useEffect(() => {
    const interval = setInterval(() => {
      const remaining = expiry - Date.now();
      if (remaining <= 0) {
        clearInterval(interval);
        setTimeLeft(0);
        onExpire();
      } else {
        setTimeLeft(remaining);
      }
    }, 1000);
    return () => clearInterval(interval);
  }, [expiry, onExpire]);

  if (timeLeft <= 0) {
    return <span className="font-bold text-amber-500">Expired</span>;
  }

  const minutes = Math.floor(timeLeft / 60000);
  const seconds = Math.floor((timeLeft % 60000) / 1000).toString().padStart(2, '0');

  return <span>{`${minutes}:${seconds}`}</span>;
};


const SyncComponent: React.FC<SyncProps> = ({ onBack, requestConfirmation }) => {
    const [mode, setMode] = useState<Mode>('idle');
    const [shareStatus, setShareStatus] = useState<ShareStatus>('generating');
    const [receiveStatus, setReceiveStatus] = useState<ReceiveStatus>('scanning');
    const [errorMessage, setErrorMessage] = useState<string | null>(null);
    const [syncPayload, setSyncPayload] = useState<{ code: string; qrData: string } | null>(null);
    const [expiryTime, setExpiryTime] = useState<number>(0);
    
    const { reloadApp } = useAppControl();

    // FIX: Refactored to resolve a circular dependency where `handleScan` needed `stopScanner`
    // before `stopScanner` was defined by the `useQrScanner` hook.
    // Now, `handleScan` just updates the state, and a `useEffect` handles stopping the scanner.
    const handleScan = useCallback(async (data: string) => {
        setReceiveStatus('connecting');

        try {
            const parsed = JSON.parse(data);
            if (!parsed.c || !parsed.k) {
                throw new Error("Invalid QR code format. Please scan the code generated by the app.");
            }
            const { c: code, k: keyJwk } = parsed;

            // 1. Fetch encrypted data from server
            const response = await fetch(`/.netlify/functions/sync?code=${code}`);
            const result = await response.json();

            if (!response.ok) {
                throw new Error(result.error || "Failed to retrieve data. The code may have expired.");
            }

            // 2. Decrypt data
            setReceiveStatus('decrypting');
            const key = await cryptoService.importKey(keyJwk);
            const decryptedJson = await cryptoService.decrypt(result.encryptedData, key);
            const importedData = JSON.parse(decryptedJson);

            // 3. Confirm with user
            setReceiveStatus('confirming');
            requestConfirmation(
                'Confirm Data Import',
                'Data has been received. This will overwrite all your current bills and settings.',
                async () => {
                    await importData(importedData);
                    setReceiveStatus('complete');
                    setTimeout(() => reloadApp(), 2000);
                },
                {
                    confirmText: 'Overwrite & Import',
                    confirmVariant: 'danger',
                    onCancel: () => {
                       // Reset to initial screen if user cancels
                       setMode('idle'); 
                    }
                }
            );
        } catch (error: any) {
            console.error("Error during receive process:", error);
            setErrorMessage(error.message || "An unknown error occurred.");
            setMode('error');
        }
    }, [requestConfirmation, reloadApp]);
    
    const { isScanning, startScanner, stopScanner, videoRef, error: scannerError } = useQrScanner(handleScan);

    // This effect stops the scanner once a QR code has been found and we've moved to the next state.
    useEffect(() => {
        if (isScanning && receiveStatus !== 'scanning') {
            stopScanner();
        }
    }, [isScanning, receiveStatus, stopScanner]);

    const startSharing = useCallback(async () => {
        setMode('sharing');
        setShareStatus('generating');
        setErrorMessage(null);
        setSyncPayload(null);
        
        try {
            const key = await cryptoService.generateKey();
            const exportedKey = await cryptoService.exportKey(key);
            const dataToExport = await exportData();
            const encryptedData = await cryptoService.encrypt(JSON.stringify(dataToExport), key);

            const response = await fetch('/.netlify/functions/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ encryptedData }),
            });
            const result = await response.json();

            if (!response.ok) {
                throw new Error(result.error || "Failed to create a sync session on the server.");
            }

            const { code } = result;
            // Use compact keys to keep QR code data smaller
            const qrPayload = JSON.stringify({ c: code, k: exportedKey });
            
            setSyncPayload({ code, qrData: qrPayload });
            setExpiryTime(Date.now() + 5 * 60 * 1000);
            setShareStatus('waiting');
        } catch (error: any) {
            console.error("Error during share process:", error);
            setErrorMessage(error.message || "An unknown error occurred.");
            setMode('error');
        }
    }, []);

    const startReceiving = () => {
        // FIX: Ensure status is reset to 'scanning' to allow the process to restart correctly.
        setReceiveStatus('scanning');
        setMode('receiving');
        startScanner();
    };

    const handleBack = () => {
        if (isScanning) stopScanner();
        setMode('idle');
        setErrorMessage(null);
        onBack();
    };
    
    useEffect(() => { return () => { if (isScanning) stopScanner(); }; }, [isScanning, stopScanner]);

    const renderIdle = () => (
        <div className="max-w-2xl mx-auto text-center">
            <button onClick={handleBack} className="flex items-center gap-2 mb-6 text-teal-600 dark:text-teal-400 font-semibold hover:text-teal-800 dark:hover:text-teal-300">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clipRule="evenodd" /></svg>
                Back to Settings
            </button>
            <div className="bg-white dark:bg-slate-800 p-8 rounded-lg shadow-lg">
                <h2 className="text-3xl font-bold text-slate-700 dark:text-slate-200 mb-2">Sync Devices</h2>
                <p className="text-slate-500 dark:text-slate-400 mb-8">Securely transfer your app data between two devices.</p>
                <div className="flex flex-col md:flex-row gap-6">
                    <button onClick={startSharing} className="flex-1 p-8 border-2 border-slate-200 dark:border-slate-700 rounded-lg hover:border-teal-500 dark:hover:border-teal-400 hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-all transform hover:-translate-y-1">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 mx-auto text-teal-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}><path strokeLinecap="round" strokeLinejoin="round" d="M9 8.25H7.5a2.25 2.25 0 00-2.25 2.25v9a2.25 2.25 0 002.25 2.25h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25H15M9 12l3 3m0 0l3-3m-3 3V2.25" /></svg>
                        <h3 className="text-xl font-bold mt-4 text-slate-800 dark:text-slate-100">Share Data</h3>
                        <p className="mt-1 text-slate-500 dark:text-slate-400">Send data from this device.</p>
                    </button>
                    <button onClick={startReceiving} className="flex-1 p-8 border-2 border-slate-200 dark:border-slate-700 rounded-lg hover:border-teal-500 dark:hover:border-teal-400 hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-all transform hover:-translate-y-1">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 mx-auto text-teal-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}><path strokeLinecap="round" strokeLinejoin="round" d="M15.75 9V5.25A2.25 2.25 0 0013.5 3h-6a2.25 2.25 0 00-2.25 2.25v13.5A2.25 2.25 0 007.5 21h6a2.25 2.25 0 002.25-2.25V15m-3 0l3-3m0 0l-3-3m3 3H9" /></svg>
                        <h3 className="text-xl font-bold mt-4 text-slate-800 dark:text-slate-100">Receive Data</h3>
                        <p className="mt-1 text-slate-500 dark:text-slate-400">Load data onto this device.</p>
                    </button>
                </div>
            </div>
        </div>
    );
    
    const renderSharing = () => (
         <div className="max-w-md mx-auto text-center">
            <div className="bg-white dark:bg-slate-800 p-8 rounded-lg shadow-lg">
                <h2 className="text-2xl font-bold text-slate-700 dark:text-slate-200 mb-2">Share Data</h2>
                {shareStatus === 'generating' && (
                    <>
                        <svg className="animate-spin h-12 w-12 text-teal-500 mx-auto my-8" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                        <p className="text-slate-500 dark:text-slate-400">Generating secure session...</p>
                    </>
                )}
                {shareStatus === 'waiting' && syncPayload && (
                    <>
                        <p className="text-slate-500 dark:text-slate-400 mb-6">On your other device, choose "Receive Data" and scan this QR code.</p>
                        <div className="my-6 p-4 bg-white rounded-lg inline-block shadow-md">
                            <img src={`https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=${encodeURIComponent(syncPayload.qrData)}&qzone=1`} alt="QR Code for sync" width="256" height="256"/>
                        </div>
                        <div className="bg-slate-100 dark:bg-slate-700 p-4 rounded-lg">
                            <p className="text-sm text-slate-500 dark:text-slate-400">Sync Code</p>
                            <p className="text-4xl font-bold tracking-widest text-slate-800 dark:text-slate-100">{syncPayload.code.replace(/(\d{3})(?=\d)/, '$1 ')}</p>
                        </div>
                        <p className="text-sm text-slate-500 dark:text-slate-400 mt-4">
                            Expires in: <CountdownTimer expiry={expiryTime} onExpire={() => setMode('error')} />
                        </p>
                    </>
                )}
                <button onClick={handleBack} className="mt-6 px-6 py-3 w-full bg-slate-100 text-slate-800 font-semibold rounded-lg hover:bg-slate-200 dark:bg-slate-700 dark:text-slate-100 dark:hover:bg-slate-600 transition-colors">
                    Done
                </button>
            </div>
        </div>
    );

    const renderReceiving = () => {
         const statusMessage = {
            scanning: 'Point your camera at the QR code on the other device.',
            connecting: 'Code found! Connecting to sync service...',
            decrypting: 'Download complete. Decrypting data...',
            confirming: 'Awaiting your confirmation...',
            complete: 'Success! Your data has been imported.'
        }[receiveStatus];
        
        return (
            <div className="max-w-xl mx-auto text-center">
                 <div className="bg-white dark:bg-slate-800 p-4 sm:p-8 rounded-lg shadow-lg relative aspect-square sm:aspect-auto">
                    <video ref={videoRef} className="w-full h-auto rounded-lg shadow-inner bg-slate-900" playsInline autoPlay/>
                    <div className="absolute inset-0 flex flex-col items-center justify-between p-4 bg-black/20 rounded-lg">
                        <div className="w-full p-3 bg-black/50 rounded-lg text-white font-semibold text-center backdrop-blur-sm">
                            <p>{statusMessage}</p>
                            {scannerError && <p className="mt-2 text-sm text-red-300 bg-red-800/80 p-2 rounded-md">{scannerError}</p>}
                        </div>
                        <button onClick={handleBack} className="px-8 py-3 bg-slate-600/70 text-white font-semibold rounded-lg text-lg backdrop-blur-sm">Cancel</button>
                    </div>
                 </div>
            </div>
        );
    };

    const renderError = () => (
         <div className="max-w-md mx-auto text-center">
            <div className="bg-white dark:bg-slate-800 p-8 rounded-lg shadow-lg">
                 <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 mx-auto text-red-500" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                </svg>
                <h2 className="text-2xl font-bold text-slate-700 dark:text-slate-200 mt-4 mb-2">Sync Failed</h2>
                <p className="text-slate-500 dark:text-slate-400 bg-red-50 dark:bg-red-900/30 p-3 rounded-md">
                    {errorMessage || "An unknown error occurred. The sync code may have expired."}
                </p>
                <button onClick={handleBack} className="mt-6 px-6 py-3 w-full bg-slate-100 text-slate-800 font-semibold rounded-lg hover:bg-slate-200 dark:bg-slate-700 dark:text-slate-100 dark:hover:bg-slate-600 transition-colors">
                    Go Back
                </button>
            </div>
        </div>
    );

    switch(mode) {
        case 'sharing': return renderSharing();
        case 'receiving': return renderReceiving();
        case 'error': return renderError();
        case 'idle':
        default:
            return renderIdle();
    }
};

export default SyncComponent;
